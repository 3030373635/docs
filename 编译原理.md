---
title: 编译原理
---


# 一、翻译

> 不改变语义的转为另一种语言程序-----目标语言程序

## 1.1 编译

> 高级语言转换为低级语言
>
> - 高级语言->机器语言：直接编译成机器语言
> - 高级语言->汇编语言->机器语言：编译成汇编语言，汇编语言汇编成机器语言

## 1.2 解释

> 一句一句的进行解释，并控制计算机执行，好比翻译，来一句翻译一句
>
> 优点：便于调试
>
> 缺点：效率低

## 1.3 什么是编译器

> 编译器是一个程序
>
> 核心功能是吧源代码转为目标代码
>
> 源代码：c/c++，java，c#，html，sql.......
>
> 目标代码：X86，ARM.......

# 二、编译器的位置

源程序->预处理器->**编译器**->汇编器->链接器/加载器->目标机器代码

- 预处理器：把存储在不同文件中的源程序聚合在一起，并且把成为**宏的缩写语句转为原始语句**
- 加载器：经过编译器，汇编器后生成**可重定位的机器代码**，加载器就是修改可重定位地址，将修改后的指令和数据放在内存适当位置
- 链接器：将多个可重定位的机器代码文件(包括库文件)连接到一起;解决外部内存地址问题

[^可重定位的机器代码]: 代码在内存中的起始位置L不是固定的

# 三、编译流程

> 1 词法分析
>
> 2 语法分析
>
> 3 语义分析和中间代码生成
>
> 4 优化
>
> 5 目标代码生成

# 四、词法分析

> 将输入进来的字符流传给词法分析器进行扫描，确定**"单词"**的类型，将识别出的单词转为记号流
>
> - 字符流：和被编译的语言密切相关，编译c语言就是c的字符流
> - 记号流：编译器内部定义的数据结构，编码所识别出的语法单元
>
> 单词类型基本有5种
>
> - 关键字
> - 标识符
> - 运算符
> - 常量
> - 界限符

**词法分析器的任务**

> 以c语言为例

### 3.1.1 手工构造法

> 顾名思义就是：自己写一个词法分析器
>
> 相对复杂，容易出错，目前非常流行的有：gcc，llvm
>
> - 通过转移图
> - 通过哈希表

**转移图**

> 从图中可以看出，转移图太麻烦了，而且关键字还是标识符的一部分

<img src="https://cos.liuqm.cc/image-20210525223537296.png">

<img src="https://cos.liuqm.cc/image-20210525223720319.png">

<img src="https://cos.liuqm.cc/image-20210525223912971.png">

**哈希表**

### 3.1.2 自动生成法

> 顾名思义就是：自动生成一个词法分析器
>
> 可快速成型，代码量少，但很难控制细节
>
> 由于写词法分析器太麻烦了，步骤分解了，只需要写了一个声明式的规范传给一个生成器，加工生成词法分析器
>
> **用正则表达式写声明式的规范**

#### 正则表达式

> 正则表达式是描述自动生成词法分析器的数学工具

<img src="https://cos.liuqm.cc/image-20210423124638718.png">

<img src="https://cos.liuqm.cc/image-20210424164615596.png">

**语法糖**

<img src="https://cos.liuqm.cc/image-20210531211003190.png">

#### 有限状态自动机

> 字符驱使着状态的改变

<img src="https://cos.liuqm.cc/image-20210531222537409.png">

**确定有限状态自动机（DFA）**

> 只有一个状态转移
>
> DFA的实现，途中用邻接矩阵来表示关系，状态集和结点集的交界为状态转移函数

<img src="https://cos.liuqm.cc/image-20210531222258577.png">

**非确定有限状态自动机（NFA）**

> 由于NFA有多个状态转移，一般把NFA转为DFA

<img src="https://cos.liuqm.cc/image-20210531222206955.png">

**正则表达式到非确定有限状态自动机的转换**

> Thompson算法：
>
> 对基本的RE直接构造
>
> 对复合的RE递归构造

<img src="https://cos.liuqm.cc/RE_NFA.jpeg" style="width:100%">

**非确定有限状态自动机转换为确定有限状态自动机**

> 子集构造法

**对确定有限状态机进行最小化**

> 最小化算法

#### DFA的代码表示

> 经过最小化算法后就要实现DFA的代码了
>
> 概念上将，DFA是一个有向图，实际上有不同的DFA的代码表示
>
> - 转移表(类似于领接矩阵)
> - 哈希表
> - 跳转表

<img src="https://cos.liuqm.cc/image-20210626221704614.png">

**转移表**

```
...
```

**跳转表**

````
...
````

# 五、语法分析

> 语法分析也叫文法分析
>
> **语法分析的任务：给定文法G和句子s（来自词法分析器），语法分析要回答的问题：是否存在对句子s的推导**
>
> 语法分析器从词法分析器输出的记号流中识别出各类短语，并构造**语法分析树（描述了句子的语法结构）**
>
> 语法分析阶段学习什么东西：
>
> - 数学理论：上下文无关文法(CFG，描述语言语法规则的数学工具)
> - 自顶向下分析
>   - 递归下降分析算法（预测分析算法）
>   - LL分析算法
> - 自底向上分析
>   - LR分析算法
>
> 为研究自然语言构造的一系列数学工具：
>
> - 3型文法：词法分析
> - 2型文法(上下文无关文法)：语法分析
> - 1型语法：上下文有关文法
> - 0型文法：任意

### 3.2.1 上下文无关文法

> 上下无关文法是研究语法规则的工具

<img src="https://cos.liuqm.cc/image-20210627213915977.png">

<img src="https://cos.liuqm.cc/image-20210627213903007.png">

<img src="https://cos.liuqm.cc/image-20210627222725430.png">

<img src="https://cos.liuqm.cc/image-20210627222857028.png">

> 上下文无关文法是一个4元组
>
> 另外规定了大写字母表示非终结符，小写字符表示终结符
>
> E->num  E->id  E->E+E.....为了简单我们表示为了 E->num|id|E+E.....

**推导和归约**

<img src="https://cos.liuqm.cc/image-20210627223017537.png">

> 推导和归约是互逆的：最右推导和最左归约、最左边推导和最右归约
>
> 最左推导：每次总是选择最左侧的非终结符进行替换
>
> 最右推导：每次总是选择最右侧的非终结符进行替换
>
> 推导：就是通过给定文法能否推导出词法分析器传来的句子
>
> 归约就是把我们的赋值语句推回成文法规定的赋值语句

### 3.2.2 分析树与二义性

> 例子：推导3+4*5
>
> 由下图：两个分析树后序遍历后结果不一致，一个为37，一个为23，导致了二义性
>
> 二义性：给定文法G，如果存在句子s，它有两颗不同的分析树，那么称G为二义性文法
>
> 从编译器的角度，二义性文法存在的问题：
>
> - 同一个程序会有不同的含义
> - 因此程序运行的结果不是唯一的，要想解决，只有重写文法G
>
> **注意：写词法分析树时，也是按最左、最右方式写**

<img src="https://cos.liuqm.cc/image-20210627235233736.png">

**重写有二义性的文法**

> 后序遍历后得出正确结果

<img src="https://cos.liuqm.cc/image-20210628001502549.png">

### 3.2.3 自顶向下分析

![image-20210628103714198](/Users/meng/Library/Application Support/typora-user-images/image-20210628103714198.png)

**下面的例子告诉我们，匹配不成功时，可以回溯**

<img src="https://cos.liuqm.cc/image-20210628103714198.png">

**回溯算法伪代码**

> 由下图可以看出，大量的回溯使时间复杂度很高，避免回溯，引出**递归下降分析算法和LL(1)分析算法**

<img src="https://cos.liuqm.cc/image-20210628111639655.png">

**递归下降分析算法和LL(1)分析算法的核心思想**

> 看下图，用之前看一下符号，避免回溯
>
> 简单意思就是：假如要进行s->N了,从tokens数组里面拿出g，以g开头的在不在N对应的产生式右部。如果在，那么N就能产生g这个终结符
>
> 但是有个缺点：如果某个产生式右侧是两个终结符，比如下图中的N->g N，以g开头的有两个，第四条与第五条产生式，如果选择了第五条产生式，**那就产生冲突了**，只有回溯了

<img src="https://cos.liuqm.cc/image-20210630211810930.png">

#### 3.2.3.1 递归下降分析算法

> 递归下降分析算法也称为预测分析
>
> 特点：
>
> - 分析高效（线性时间）
> - 容易实现（方便手工编码）
> - 错误定位和诊断信息准确
> - 被很多开源和商业的编译器所采用的
>
> 算法基本思想：
>
> - 每个非终结符构造一个分析函数
> - 用**前看符号**指导产生式规则的选择

**避免回溯第一版**

<img src="https://cos.liuqm.cc/image-20210701091124818.png">

#### 3.2.3.2 LL(1)分析算法

> **从左(L)向右读取程序，对文法左(L)推导，采用一个(1)向前看符号（就是tokens里面未处理的符号来辅助判断，决定来做推导）**
>
> 特点：
>
> - 分析高效
> - 错误定位和诊断信息准确
> - 有很多开源或者商业的生成工具
>
> 缺点：
>
> - 能分析的文法类型受限
> - 往往需要文法的改写
>
> 算法基本思想：表驱动的分析算法

<img src="https://cos.liuqm.cc/image-20210701103153998.png">

**first集**

> 构造LL(1)分析表的组件之一

**1 非终结符的first集**

<img src="https://cos.liuqm.cc/image-20210701110946954.png">

**2 终结符的first集**

<img src="https://cos.liuqm.cc/image-20210701124238078.png">

<img src="https://cos.liuqm.cc/image-20210701112919906.png">

**3 first集合完整计算**

> 之前计算的first集没有考虑非终结符还能推出空的情况，一旦有个非终结符推出空了，那么以xxx开头的就会变了

<img src="https://cos.liuqm.cc/image-20210701153746696.png">

<img src="https://cos.liuqm.cc/image-20210701160612011.png">

**构造LL(1)分析表**

<img src="https://cos.liuqm.cc/image-20210701124511829.png">

**LL(1)分析表的冲突**

<img src="https://cos.liuqm.cc/image-20210701124820831.png">

**一般条件下的LL(1)分析构造**

<img src="https://cos.liuqm.cc/image-20210701151736862.png">

**1 NULLABLE集的计算**

> 说白了就是将只要可以推出空串的非终结符都加入到NULLABLE集合里面去，因为first集合后面要用到NULLABLE集合

<img src="https://cos.liuqm.cc/image-20210701151905035.png">

<img src="https://cos.liuqm.cc/image-20210701151940399.png">

**2 FOLLOW集的计算**

**LL(1)分析算法冲突解决**

**消除左递归**

<img src="https://cos.liuqm.cc/image-20210701203035546.png">

**2 提取左公因子**

<img src="https://cos.liuqm.cc/image-20210701203652874.png">

### 3.2.4 自底向上分析

> 语法分析器最常用最广泛的一类语法分析算法
>
> LR分析算法(移进-归约算法)
>
> - 算法运行高效
> - 有现成的工具可用
>
> 跟LL(1)对比：能够分析更多的文法，并且一般不需要对文法进行特殊的处理，比如消除左递归

**自底向上分析的思想**

#### 3.2.4.1 LR(0)分析算法

# 六、中间代码生成

> 中间代码是在语法分析正确基础上，按照语义规则产生一种介于源语言与目标代码之间的一种代码
>
> 中间代码形式有很多种：四元式(常用)，三元式和逆波兰形
>
> 人有逻辑思维，计算机不知道怎么下手，这里用四元式，这样写出来后，可以直接用汇编语言

<img src="https://cos.liuqm.cc/image-20210325165251043.png">

# 七、优化

> 对前面产生的中间代码进行优化
>
> 原则：等价变化
>
> 主要方面：公共子表达式的提取，合并已知量，删除无用语句，循环优化等

**例如**

<img src="https://cos.liuqm.cc/image-20210325170402476.png">

<img src="https://cos.liuqm.cc/image-20210325170452314.png">

**例子**

<img src="https://cos.liuqm.cc/image-20210325192914795.png">

<img src="https://cos.liuqm.cc/image-20210325192933463.png">

> 从图中可以看出有两个10*k，有点重复，并且可以看出，mn随着k的自加，每次只会增长10，所以可以写成m = m + 10，n = n + 10

<img src="https://cos.liuqm.cc/image-20210325193719272.png">

> 从上图可以看出，循环当中没有了乘法，只有加法，并且加法执行200次，而上面乘法和加法各200次

# 八、目标代码生成

> 目标代码的形式：
>
> - 绝对指令代码：可立即执行，二进制代码
> - 汇编指令代码：汇编语言程序，需要通过汇编程序汇编
> - 可重定位指令代码：将目标模块连接起来，确定变量常数在主存中的位置，装入主存后能成为绝对指令代码

# 九、表格与表格管理

<img src="https://cos.liuqm.cc/image-20210325195600186.png">

> 用来记录源程序的各种信息以及编译过程中的状况

## 符号表

> 用来登记源程序中的常量名，变量名，数组名，过程名，引用情况等，**好像就是存名字和内存关系的表**
>
> **思考：为什么不将变量名直接放在符号表，而是放在了字符串表**

<img src="https://cos.liuqm.cc/image-20210326092744173.png">

## 常数表

> 存名字对应的值的表，什么小数，整数

<img src="https://cos.liuqm.cc/image-20210326092720263.png">

## 标号表

<img src="https://cos.liuqm.cc/image-20210326093108792.png">

## 分程序入口表

> 程序有若干个过程

<img src="https://cos.liuqm.cc/image-20210326093223729.png">

## 中间代码表

> 就是中间代码阶段用的表

# 出错处理

## 错误类型

### 语法错误

### 语义错误

> 比如10/b  b是一个未知的变量可能为0，这就是一个语义错误

### 逻辑错误(不处理)

> 编译不处理逻辑错误
>
> 例如：for(int i = 0;i <k;i++){} 万一k是个万无穷大的数，这就是一个死循环

# 遍

> 对源程序或者源程序的中间结果从头到尾扫描一次，并作有关的加工处理，生成新的中间结果或目标代码，**其实就是说一遍就完成了编译过程**

## 一遍扫描

<img src="https://cos.liuqm.cc/image-20210326095408384.png">

## 多遍扫描

> 优点：节约内存空间
>
> 缺点：扫描多遍，编译时间较长

# 编译程序生成

- 机器语言编写的编译程序
- 汇编语言编写的编译程序
- 高级语言编写的编译程序**(这是常用方法)**
- 自编译
- 编译工具
- 移植

# 编译程序构造

> 为某种语言构造编译程序要掌握下面三个方面

- 源语言
- 目标语言
- 编译方法

# 字母表与符号表

> 任何一个程序都可以看成是字母表上的字符串

<img src="https://cos.liuqm.cc/image-20210403114325943.png">

## 符号串运算

### 长度

> 符号串中符号的个数为符号串的长度，假设**x**是符号串，则**|x|**表示符号串的长度
>
> 例如|abc| = 3 ，空串长度为0,用左右翻转的数字3表示

### 连接

> 符号串x和y连接，将y连接在x后面
>
> **例如：x = ab    y = bc      xy = abbc  yx = bcab**

### 幂运算

<img src="https://cos.liuqm.cc/image-20210403114956899.png">

## 符号串集合的运算

### 乘积运算

<img src="https://cos.liuqm.cc/image-20210403115023926.png">

### 幂运算

<img src="https://cos.liuqm.cc/image-20210403122336107.png">

### 闭包

<img src="https://cos.liuqm.cc/image-20210403122640044.png">