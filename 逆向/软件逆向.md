# 什么是程序

> 算法 + 数据结构 = 程序

# 如何分析程序

- 程序从哪里开始

- 代码存在哪里

- 数据存在哪里

# 寄存器与内存的区别

- 寄存器位于CPU内部，执行速度快，但比较贵。												
- 内存速度相对较慢，但成本较低，所以可以做的很大。											
- 寄存器和内存没有本质区别，都是用于存储数据的容器，都是定宽的。										
- 寄存器常用的有8个：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI。											
- 计算机中的几个常用计量单位：BYTE WORD DWORD											
  BYTE　字节　＝　8(BIT)							
  WORD  字    =   16(BIT)							
  DWORD 双字  =   32(BIT)							
  				
  1KB = 1024 BYTE							
  1MB = 1024 KB 							
  1GB = 1024 MB							

我们平常称计算机为32位或者64位，有很多书上说之所以叫32位计算机是因为寄存器的宽度是32位的，这个说法是不准确的，还有很多寄存器是大于32位的，64、32位计算机指的是，内存的寻址宽度

计算机中的内存以字节为单位，为每个字节分配一个编号，即

0x00000000

0x00000001

0x00000002

.........

0xFFFFFFFF

为什么32位计算机的最大内存为4G：0x00000000-0xFFFFFFFF有0x100000000个字节，换算成10进制就是2**32次方个字节

# 进制

1. 数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的，如果超出范围，就会被舍弃。
2. 4位宽度表示：假设计算机只能存储4位2进制数，那么可以存储0000-1111，换算10进制就是0-15，也就是说4位2进制的宽度，可以存储10进制0-15。

关于计算机中第一位为1表示负数的说法：

关于计算机中第一位为0表示正数的说法：

假设计算机存储4位的二进制，那么可能存：0000 0001 0002 ..... 1111，换算10进制就0-15，也就是可以存16个数，然后切一半，左边都是0开头的，右边都是1开头的，那么0开头的就可以存储正数，1开头的就可以存储负数

# 计算机运算本质

计算机的运算都是使用逻辑运算

cpu如何计算加法：例如2+3，取异或后，再取与

# 寄存器

## 通用寄存器

### 累加器

> 用于存放算术逻辑运算中的操作数，另外所有的IO指令都可以使用累加器与外部接口传送数据

- EAX = `[][][][]AX`，AX=`AH AL`
- AX 16位
- AL 8位

### 地址寄存器

> 常用来存放访问内存时的基地址

- EBX 32位
- BX 16位
- BL 8位





### ECX

### EDX

### ESP

### EBP

### ESI

### EDI

# 操作指令

常用操作指令

## jmp

> 修改eip寄存器的值，eip存储着cpu下一个需要执行的命令的内存地址

## call与ret

call 0x12345678，push下一条指令地址到esp，然后在执行

ret，相当于pop eip

## mov

> mov 目标操作数 源操作数
>
> - 源操作数可以是立即数，通用寄存器、段寄存器，或者内存单元
> - 目标操作数可以是通用寄存器，段寄存器，或者内存单元
> - 操作数的宽度必须一样（位数）
> - 源操作数和目标操作数不能同时为内存单元

## cmp

```
				
指令格式：CMP  R/M,R/M/IMM			R：寄存器，M：内存，IMM：立即数
			
该指令是比较两个操作数,实际上,它相当于SUB指令,但是不会保存结果		
			
只是根据相减的结果来改变零标志位的,当两个操作数相等的时候,零标志位置1。			
			
MOV EAX,100			
MOV ECX,100			
CMP EAX,ECX			观察Z位，判断两数是否相等
			
			
MOV EAX,100			
MOV ECX,200			
CMP EAX,ECX			观察S位，判断谁大，谁小，
			
			
CMP AX,WORD PTR DS:[405000]			
			
CMP AL,BYTE PTR DS:[405000]			
			
CMP EAX,DWORD PTR DS:[405000]			
```

## test

```
指令格式：TEST  R/M,R/M/IMM			
			
求与运算，结果不保存,但是会改变相应标志位.			
			
			
常见用法：用这个指令,可以确定某寄存器是否等于0。			
			
TEST EAX,EAX			观察Z位
			
但是如果EAX的二进制某些位为1的话,那么运算的结果就不为零。			
```

## 2、从指定内存中写入/读取数据									

```			
mov dword ptr ds:[0x0012FF34],0x12345678				

mov eax,dword ptr ds:[0x0012FF34]				

dword ：要读/写多少  此时是4字节   byte == 1字节  word == 2字节				

ptr: Point 代表后面是一个指针 (指针的意思就是里面存的不是普通的值，而是个地址)				

ds：段寄存器 先不用管 记住就行				

0x0012FF34:内存编号，必须是32位的  前面0可以省略				

注意：地址编号不要随便写，因为内存是有保护的，并不是所有的内存都可以直接读写(需要特别处理)				

建议地址编号写成esp的值	
```



# 寻址方式

寻址公式一：`[立即数]`
                                                                                
寻址公式二：`[reg]  reg代表寄存器 可以是8个通用寄存器中的任意一个`
                                                
寻址公式三：`[reg+立即数] `
                                                                                
寻址公式四：`[reg+reg*{1,2,4,8}] `
                                                                                
寻址公式五：`[reg+reg*{1,2,4,8}+立即数] `

# 堆栈

  PUSHAD指令：将8个通用寄存器的值放入堆栈
  POPAD指令 ：将8个通用寄存器的值取出来

## 标志寄存器

**进位标志CF（carry flag）**：运算结果的最高位产生了一个进位或者借位，那么其值为1，否则为0

```
mov al,0xFF
add al,2
```

**奇偶标志PF（parity flag）**：反应运算结果中1的个数，1的个数为奇数则为0，否则为1，**notes：只看最后一个字节**

```
mov eax,0x804
add eax,0x01
```

**辅助进位标志AF（Auxiliary Carry Flag）**：

```
在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：             
              
(1)、在字操作时，发生低字节向高字节进位或借位时；              
              
(2)、在字节操作时，发生低4位向高4位进位或借位时。             
              
MOV EAX,0x55EEFFFF      MOV AX,5EFE     MOV AL,4E 
ADD EAX,2     ADD AX,2      ADD AL,2  
```

**零标志ZF（zero flag）**：用来反映运算结果是否为0，运算结果为0其值为1，反之亦然。

```
XOR EAX,EAX   对eax与eax取异或后的值，放入eax，notes：对同一个值取异或，结果为0
MOV EAX,2
SUB EAX,2   
```

**符号标志SF（sign flag）**：反映运算结果的符号位，它与运算结果的最高位相同

```
MOV AL,7F 
ADD AL,2  
```

**溢出标志OF(Overflow Flag)**：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。  如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。
